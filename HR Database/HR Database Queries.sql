--Þirketimizde halen çalýþmaya devam eden çalýþanlarýn listesini getiren sorgu hangsidir?
--Not: Ýþten çýkýþ tarihi boþ olanlar çalýþmaya devam eden çalýþanlardýr.

SELECT * FROM PERSON
WHERE OUTDATE IS NULL

--Þirketimizde departman bazlý halen çalýþmaya devam ede KADIN ve ERKEK sayýlarýný geiten sorguyu yazýnýz.

SELECT 
D.DEPARTMENT,
CASE 
	WHEN P.GENDER='E' THEN 'Erkek'
	ELSE 'Kadýn'
END AS GENDER
, COUNT(P.ID) AS PERSONCOUNT 
FROM PERSON P 
INNER JOIN DEPARTMENT D ON D.ID=P.DEPARTMENTID

WHERE P.OUTDATE IS NULL
GROUP BY D.DEPARTMENT,GENDER
ORDER BY 1,2

--Sütun olarak gösterim

SELECT *,
(SELECT COUNT(*) FROM PERSON WHERE DEPARTMENTID = D.ID AND GENDER='E' AND OUTDATE IS NULL ) AS MALE_PERSONCOUNT,
(SELECT COUNT(*) FROM PERSON WHERE DEPARTMENTID = D.ID AND GENDER='K'AND OUTDATE IS NULL ) AS FEMALE_PERSONCOUNT

FROM DEPARTMENT D
ORDER BY D.DEPARTMENT

--Þirketimizin Planlama departmanýna yeni bir þef atamasý yapýldý ve maaþý belirlemek istiyoruz.
--Planlama departmaný için minimum ve maksimim ve ortalama þef maaþý getiren sorgu hangisidir?
--(Not: Ýþten çýkmýþ olan personel maaþlarý da dahildir.)

SELECT
POS.POSITION,
MIN(P.SALARY) AS MIN_SALARY,
MAX(P.SALARY) AS MAX_SALARY,
ROUND(AVG(P.SALARY),0) AS AVG_SALARY
FROM POSITION POS
INNER JOIN PERSON P ON P.POSITIONID=POS.ID
WHERE POS.POSITION='PLANLAMA ÞEFÝ'
GROUP BY POS.POSITION

--SUBQUERY ÝLE

SELECT 
POS.POSITION,
(SELECT MIN(SALARY) FROM PERSON WHERE POSITIONID=POS.ID) AS MIN_SALARY,
(SELECT MAX(SALARY) FROM PERSON WHERE POSITIONID=POS.ID) AS MAX_SALARY,
(SELECT ROUND(AVG(SALARY),0) FROM PERSON WHERE POSITIONID=POS.ID) AS AVG_SALARY
FROM POSITION POS
WHERE POS.POSITION='PLANLAMA ÞEFÝ'

--Her bir pozisyonda mevcut halde çalýþanlar olarak kaç kiþi ve ortalama maaþlarýnýn ne kadar olduðunu listelettirmek istiyoruz. Bu sonucu getiren sorguyu yazýnýz.
SELECT POS.POSITION,COUNT(P.ID) AS PERSONCOUNT,
ROUND(AVG(P.SALARY),0) AS AVG_SALARY
FROM POSITION POS
INNER JOIN PERSON P ON P.POSITIONID=POS.ID
WHERE OUTDATE IS NOT NULL
GROUP BY POS.POSITION
ORDER BY POS.POSITION

--SUBQUERY ÝLE
SELECT 
POS.POSITION,
(SELECT COUNT(*) FROM PERSON WHERE POSITIONID=POS.ID) AS PERSONCOUNT,
(SELECT ROUND(AVG(SALARY),0) FROM PERSON WHERE POSITIONID=POS.ID) AS AVG_SALARY
FROM POSITION POS

ORDER BY POS.POSITION

--Yýllara göre iþe alýnan personel saysýný kadýn ve erkek bazýnda listelettiren sorguyu yazýnýz.

SELECT DISTINCT YEAR(P.INDATE) YEAR_,
(SELECT COUNT(*) FROM PERSON WHERE GENDER='E' AND YEAR(INDATE)=YEAR(P.INDATE)) AS MALE_PERSON,
(SELECT COUNT(*) FROM PERSON WHERE GENDER = 'K' AND YEAR(INDATE)=YEAR(P.INDATE)) AS FEMALE_PERSON
FROM PERSON P
ORDER BY 1

--Her bir personelimizin ne kadar zamandýr çalýþtýðý bilgisini þekildeki gibi ay olarak getiren sorguyu yazýnýz.
SELECT NAME_+' '+SURNAME AS PERSON,
INDATE,OUTDATE,
CASE 
	WHEN OUTDATE IS NOT NULL THEN 'ÝÞTEN AYRILDI'
	ELSE 'DEVAME EDÝYOR'
END AS WORKINGSTATUS,
CASE
	WHEN OUTDATE IS NOT NULL THEN DATEDIFF(MONTH,INDATE,OUTDATE)
	ELSE DATEDIFF(MONTH,INDATE,GETDATE())
END AS WORKINGTIME
FROM PERSON

--DIFFERENT METHOD SAME QUERY

SELECT NAME_+' '+SURNAME AS PERSON,
INDATE,OUTDATE,DATEDIFF(MONTH,INDATE,GETDATE()) AS WORKINGTIME
FROM PERSON WHERE OUTDATE IS NULL
UNION ALL
SELECT NAME_+' '+SURNAME AS PERSON,
INDATE,OUTDATE,DATEDIFF(MONTH,INDATE,OUTDATE) AS WORKINGTIME
FROM PERSON WHERE OUTDATE IS NOT NULL

--Þirketimiz 5. yýlýnda üstünde herkesin isminin ve soyisminin baþ harflerinin bulunduðu bir ajanda bastýrýp çalýþanlarýna
--hediye edecektir. Bunun için hangi harf kombinasyonundan en az ne kadar sayýda ajanda bastýralacaðý sorusunun cevabýný getiren
--sorguyu yazýnýz.
--NOT: Ýki isimli olanlarýn birinci isminin baþ harfi kullanýlacaktýr.

SELECT SUBSTRING(NAME_,1,1)+'.'+ SUBSTRING(SURNAME,1,1)+'.' AS SHORTNAME,
COUNT(*) AS PERSONCOUNT

FROM PERSON
GROUP BY SUBSTRING(NAME_,1,1), SUBSTRING(SURNAME,1,1)
ORDER BY COUNT(*) DESC

--Maaþ ortalamasý 5.500 TL'den fazla olan departmanlarý listeyecek sorguyu yazýnýz.

SELECT D.DEPARTMENT,ROUND(AVG(P.SALARY),1) AS AVGSALARY 
FROM DEPARTMENT D 
INNER JOIN PERSON P ON P.DEPARTMENTID=D.ID
GROUP BY D.DEPARTMENT
HAVING ROUND(AVG(P.SALARY),1)>5500

--SUBQUERY
SELECT DEPARTMENT,
(SELECT ROUND(AVG(SALARY),0) FROM PERSON WHERE DEPARTMENTID=D.ID) AS AVGSALARY
FROM DEPARTMENT D

WHERE (SELECT AVG(SALARY) FROM PERSON WHERE DEPARTMENTID=D.ID)>5500

--DIFFERENT METHOD SAME QUERY (DYNAMIC VIEW)
SELECT * FROM (
SELECT D.DEPARTMENT,ROUND(AVG(P.SALARY),1) AS AVGSALARY 
FROM DEPARTMENT D 
INNER JOIN PERSON P ON P.DEPARTMENTID=D.ID
GROUP BY D.DEPARTMENT
) T WHERE AVGSALARY>5500

--Departmanlarýn ortalama kýdemeni at olarak hesaplayacak soruguyu  yazýnýz.
SELECT DEPARTMENT, AVG(AVG_WORKINGTIME) 
FROM (
SELECT D.DEPARTMENT,
CASE
	WHEN P.OUTDATE IS NULL THEN DATEDIFF(MONTH,P.INDATE,GETDATE())
	ELSE DATEDIFF(MONTH,P.INDATE,P.OUTDATE)
END AS AVG_WORKINGTIME
FROM PERSON P 
INNER JOIN DEPARTMENT D ON D.ID=P.DEPARTMENTID
) T 
GROUP BY DEPARTMENT
ORDER BY 1

--Her personelin adýný,pozisyonuna baðlý olduðu birim yöneticisinin adýný ve pozisyonunu þekildeki gibi getiren sorguyu yazýnýz.

SELECT P.NAME_+' '+P.SURNAME AS PERSON,POS.POSITION,
P2.NAME_+' '+P2.SURNAME AS MANAGERNAME,
POS2.POSITION AS MANAGERPOSITION
FROM PERSON P 
INNER JOIN POSITION POS ON POS.ID=P.POSITIONID
INNER JOIN PERSON P2 ON P.MANAGERID=P2.ID
INNER JOIN POSITION POS2 ON POS2.ID=P2.POSITIONID

